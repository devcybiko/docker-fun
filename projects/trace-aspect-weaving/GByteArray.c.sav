#include "GByteArray.h"

GByteArray *GByteArray_new(int extent)
{
    TRACE("> GByteArray.new extent=%d\n", extent);
    if (GByteArray$.id == 0) _initClass();
    GByteArray *this = NEW(GByteArray);
    TRACE("this = %p\n", this);
    this->class = &GByteArray$;
    _(this).init(GByteArray_ID, extent);
    TRACE("< GByteArray.new extent=%d\n", extent);
    return this;
}

static void init(int id, int extent)
{
    GByteArray *this = _THIS_; // special case for init
    TRACE("> GByteArray.init %p\n", this);
    __(this).init(id);
    this->used = 0;
    this->extent = extent;
    this->bytes = CALLOC(extent, char);
    TRACE("< GByteArray.init %p\n", this);
}

static void delete()
{
    GByteArray *this = THIS(GByteArray, "GByteArray.delete");
    TRACE("> GByteArray.delete %p\n", this);
    FREE(this->bytes);
    __(this).delete();
    TRACE("< GByteArray.delete %p\n", this);
}

static void debug(char *fmt, ...)
{
    va_list args;
    va_start(args, fmt);
    GByteArray *this = THIS(GByteArray, "GByteArray.debug");
    TRACE("> GByteArray.debug %p\n", this);
    __(this).debug(fmt, args);
    TRACE("< GByteArray.debug %p\n", this);
}

static char *alloc(int n) {
    GByteArray* this = THIS(GByteArray, "GByteArray.alloc");
    TRACE("> GByteArray.get %p n=%d\n", this, n);
    if (n < 0 || this->used + n >= this->extent) return NULL;
    char *s = &this->bytes[this->used];
    this->used += n;
    TRACE("< GByteArray.get %p, ptr=%s, used=%d, extent=%d\n", this, s, this->used, this->extent);
    return s;
}

GByteArrayClass GByteArray$;
static void _initClass() {
    TRACE("> GByteArray$._initClass\n");
    memcpy(&GByteArray$, &GObj$, sizeof(GObj$));
    GByteArray$.name = "GByteArray";
    GByteArray$.id = GByteArray_ID;
    GByteArray$.super = &GObj$;
    GByteArray$.init = init;
    GByteArray$.delete = delete;
    GByteArray$.debug = debug;
    GByteArray$.alloc = alloc;
    TRACE("< GByteArray$._initClass\n");
}
